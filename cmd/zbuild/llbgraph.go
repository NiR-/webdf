package main

import (
	"io/ioutil"

	"github.com/NiR-/zbuild/pkg/llbgraph"
	"github.com/NiR-/zbuild/pkg/llbutils"
	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"
)

var llbgraphFlags = struct {
	input    string
	output   string
	rawAttrs bool
}{}

func newLLBGraphCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:    "llbgraph",
		Hidden: true,
		Short:  "Output LLB DAG in DOT format.",
		Long: `Output LLB DAG in DOT format.

Transform a JSON dump created with ` + "`zbuild debug-llb`" + `into a DOT digraph
representation. This can be used to take insights about what build steps are
generated by zbuild.

Example (feh is used to open up the generated PNG file):

	$ zbuild debug-llb --json | zbuild llbgraph | dot /dev/stdin -o /dev/stdout -T png | feh -
`,
		Run: HandleLLBGraphCmd,
	}

	cmd.Flags().StringVar(&llbgraphFlags.input, "input", "-", "Where the input JSON file is located (use - or left empty to use stdin)")
	cmd.Flags().StringVar(&llbgraphFlags.output, "output", "", "Where the PNG file should be written.")
	cmd.Flags().BoolVar(&llbgraphFlags.rawAttrs, "raw", false, "Include raw LLB ops in node labels")

	return cmd
}

func HandleLLBGraphCmd(cmd *cobra.Command, args []string) {
	if llbgraphFlags.input == "-" || llbgraphFlags.input == "" {
		llbgraphFlags.input = "/dev/stdin"
	}
	if llbgraphFlags.output == "-" || llbgraphFlags.output == "" {
		llbgraphFlags.output = "/dev/stdout"
	}

	rawJSON, err := ioutil.ReadFile(llbgraphFlags.input)
	if err != nil {
		logrus.Fatalf("%+v", err)
	}

	def, err := llbutils.JSONToDefinition(rawJSON)
	if err != nil {
		logrus.Fatalf("%+v", err)
	}

	opts := llbgraph.GraphOpts{
		RawAttrs: llbgraphFlags.rawAttrs,
	}
	g, err := llbgraph.ToDotGraph(def, opts)
	if err != nil {
		logrus.Fatalf("%+v", err)
	}

	rawGraph, err := g.MarshalText()
	if err != nil {
		logrus.Fatalf("%+v", err)
	}
	ioutil.WriteFile(llbgraphFlags.output, []byte(rawGraph), 0640) //nolint:errcheck
}
